BEGIN
Symbol table level 0
 0:  7521968        sqrt  VAR    2 typ    NULL  lvl  0  siz -842150451  off -842150451
 1:  7522104        _ord  knd 5 1  typ 0  lvl  0  siz -842150451  off -842150451
(FUNCTION)
 2:  7521832       _sqrt  knd 5 2  typ 0  lvl  0  siz -842150451  off -842150451
(FUNCTION)
 3:  7542232      readln  VAR    -1 typ    NULL  lvl  0  siz -842150451  off -842150451
 4:  7522376        _chr  knd 5 4  typ 0  lvl  0  siz -842150451  off -842150451
(FUNCTION)
 5:  7544544       write  VAR    4 typ    NULL  lvl  0  siz -842150451  off -842150451
 6:  7496464     integer  BASIC  basicType   1          siz     4
 7:  7542776     _readln  knd 5 -1  typ 0  lvl  0  siz -842150451  off -842150451
(FUNCTION)
 8: NULL
 9: NULL
10: NULL
11: NULL
12: NULL
13:  7540736        _odd  knd 5 1  typ 0  lvl  0  siz -842150451  off -842150451
(FUNCTION)
14: NULL
15:  7521560        _sqr  knd 5 2  typ 0  lvl  0  siz -842150451  off -842150451
(FUNCTION)
16: NULL
17: NULL
18: NULL
19: NULL
20:  7542368        pred  VAR    4 typ    NULL  lvl  0  siz -842150451  off -842150451
21:  7544408      _write  knd 5 -1  typ 0  lvl  0  siz -842150451  off -842150451
(FUNCTION)
22:  7522648       _pred  knd 5 4  typ 0  lvl  0  siz -842150451  off -842150451
(FUNCTION)
23: NULL
24:  7522240         ord  VAR    1 typ    NULL  lvl  0  siz -842150451  off -842150451
25:  7544272        read  VAR    -1 typ    NULL  lvl  0  siz -842150451  off -842150451
26:  7540872    _writeln  knd 5 -1  typ 0  lvl  0  siz -842150451  off -842150451
(FUNCTION)
27:  7541280       _read  knd 5 -1  typ 0  lvl  0  siz -842150451  off -842150451
(FUNCTION)
28:  7542640       _succ  knd 5 4  typ 0  lvl  0  siz -842150451  off -842150451
(FUNCTION)
29: NULL
30: NULL
Symbol table level 1
 0: NULL
 1: NULL
 2: NULL
 3: NULL
 4: NULL
 5: NULL
 6: NULL
 7:  7542912          go  VAR    1 typ integer  lvl  1  siz     4  off     4
 8: NULL
 9: NULL
10: NULL
11: NULL
12: NULL
13: NULL
14: NULL
15: NULL
16: NULL
17: NULL
18:  7543048           a  VAR    1 typ integer  lvl  1  siz     4  off     0
19: NULL
20: NULL
21: NULL
22: NULL
23: NULL
24: NULL
25: NULL
26: NULL
27: NULL
28: NULL
29: NULL
30: NULL
test
©À  begin
  ©À  :=
    ©À  a
    ©À  5
  ©À  :=
    ©À  go
    ©À  3
  ©À  if
    ©À  =
      ©À  a
      ©À  1
    ©À  begin
      ©À  :=
        ©À  go
        ©À  1
    ©À  begin
      ©À  if
        ©À  =
          ©À  a
          ©À  2
        ©À  begin
          ©À  :=
            ©À  go
            ©À  1
        ©À  begin
          ©À  :=
            ©À  go
            ©À  a
	jmp	.L0 			#  jump 
# ---------------------- Beginning of Generated Code --------------------
        .file   "foo"
        .text
.globl test
        .type   test, @function
test:
.LFB0:
	.cfi_startproc
	pushq	%rbp              # save base pointer on stack
	.cfi_def_cfa_offset 16
	movq	%rsp, %rbp        # move stack pointer to base pointer
	.cfi_offset 6, -16
	.cfi_def_cfa_register 6
        subq	$32, %rsp 	  # make space for this stack frame
	movq	%rbx, %r9        # save %rbx (callee-saved) in %r9
# ------------------------- begin Your code -----------------------------
.L0:
Bad code token	movl	%eax,-32(%rbp)     	#  %eax -> a
	movl	%eax,-28(%rbp)     	#  %eax -> go
Bad code token	movl	-32(%rbp),%eax     	#  a -> %eax
	cmpl	%ebx,%eax           	#  compare %eax - %ebx
	je	.L1 			#  jump if     ==
	jmp	.L2 			#  jump 
.L1:
Bad code token	movl	%eax,-28(%rbp)     	#  %eax -> go
	jmp	.L3 			#  jump 
.L2:
Bad code tokenBad code token	movl	-32(%rbp),%eax     	#  a -> %eax
	cmpl	%ebx,%eax           	#  compare %eax - %ebx
	je	.L4 			#  jump if     ==
	jmp	.L5 			#  jump 
.L4:
Bad code token	movl	%eax,-28(%rbp)     	#  %eax -> go
	jmp	.L6 			#  jump 
.L5:
Bad code token	movl	-32(%rbp),%eax     	#  a -> %eax
	movl	%eax,-28(%rbp)     	#  %eax -> go
.L6:
.L3:
# ----------------------- begin Epilogue code ---------------------------
	movq	%r9, %rbx        # restore %rbx (callee-saved) from %r9
        leave
        ret
        .cfi_endproc
.LFE0:
        .size   test, .-test
# ----------------- end Epilogue; Literal data follows ------------------
        .section        .rodata

        .ident  "Compiler Principle - Spring 2017"
